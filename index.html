<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
<title>Mobile VR Dev Kit</title>
<style>
    /* --- 基本スタイル --- */
    :root {
        --bg-color: #1e1e1e;
        --editor-bg: #2d2d2d;
        --text-color: #e0e0e0;
        --accent-color: #007acc;
        --danger-color: #d9534f;
        --ui-overlay-bg: rgba(0, 0, 0, 0.6);
    }
    body {
        margin: 0; padding: 0;
        background-color: var(--bg-color);
        color: var(--text-color);
        font-family: monospace;
        height: 100vh;
        overflow: hidden;
        display: flex;
        flex-direction: column;
    }
    button, select {
        font-family: sans-serif;
        touch-action: manipulation;
    }

    /* --- 1. エディタ画面 UI --- */
    #editor-screen {
        display: flex;
        flex-direction: column;
        height: 100%;
        padding: 10px;
        box-sizing: border-box;
    }
    .toolbar {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
        margin-bottom: 8px;
        align-items: center;
    }
    .toolbar-group {
        display: flex;
        gap: 4px;
        background: #333;
        padding: 4px;
        border-radius: 6px;
    }
    select {
        background: #444; color: #fff; border: 1px solid #555;
        padding: 8px; border-radius: 4px; font-size: 14px;
    }
    .btn {
        background: #444; color: #fff; border: none;
        padding: 8px 12px; border-radius: 4px; font-size: 13px; cursor: pointer;
    }
    .btn:active { background: #666; }
    .btn-primary { background: var(--accent-color); font-weight: bold; }
    .btn-danger { background: var(--danger-color); }
    
    #code-area {
        flex-grow: 1;
        background-color: var(--editor-bg);
        color: #fff;
        border: 1px solid #444;
        padding: 10px;
        font-size: 14px;
        resize: none;
        outline: none;
        border-radius: 4px;
        white-space: pre;
        overflow-x: auto;
    }

    #run-btn {
        margin-top: 10px;
        padding: 15px;
        font-size: 18px;
        background: #0a0;
        color: white;
        border: none;
        border-radius: 6px;
        width: 100%;
    }

    /* --- 2. VRエミュレータ画面 UI --- */
    #emulator-screen {
        display: none; /* 初期状態は非表示 */
        position: fixed;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #000;
        z-index: 100;
    }
    
    /* 実行されるiframe */
    #vr-frame {
        width: 100%; height: 100%; border: none;
        display: block;
    }

    /* オーバーレイUI */
    #exit-btn {
        position: absolute;
        top: 10px; left: 10px;
        width: 40px; height: 40px;
        background: rgba(255, 0, 0, 0.7);
        color: white;
        border: 2px solid white;
        border-radius: 50%;
        font-size: 24px;
        line-height: 36px;
        text-align: center;
        z-index: 200;
        cursor: pointer;
    }
    
    #controls-overlay {
        position: absolute;
        bottom: 0; left: 0; width: 100%; height: 40%;
        display: flex;
        justify-content: space-between;
        align-items: flex-end;
        padding: 20px;
        box-sizing: border-box;
        pointer-events: none; /* 下のcanvasへのタッチを阻害しないように */
    }

    /* コントローラーパーツ */
    .control-zone {
        pointer-events: auto; /* ボタン部分はタッチ有効 */
        background: rgba(50, 50, 50, 0.5);
        border-radius: 20px;
        padding: 10px;
        display: flex;
        flex-direction: column;
        align-items: center;
        gap: 10px;
    }

    .v-btn {
        width: 50px; height: 50px;
        background: rgba(255, 255, 255, 0.2);
        border: 2px solid rgba(255, 255, 255, 0.5);
        border-radius: 50%;
        color: white;
        font-weight: bold;
        display: flex; justify-content: center; align-items: center;
        user-select: none;
    }
    .v-btn:active { background: rgba(0, 255, 0, 0.5); border-color: #0f0; }

    #joystick-area {
        width: 120px; height: 120px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 50%;
        position: relative;
        touch-action: none;
    }
    #joystick-knob {
        width: 50px; height: 50px;
        background: rgba(0, 150, 255, 0.8);
        border-radius: 50%;
        position: absolute;
        top: 50%; left: 50%;
        transform: translate(-50%, -50%);
        pointer-events: none;
    }
    
    #gyro-status {
        position: absolute; top: 10px; right: 10px;
        color: lime; font-size: 12px;
        background: rgba(0,0,0,0.5); padding: 4px;
    }
</style>
</head>
<body>

    <div id="editor-screen">
        <div class="toolbar">
            <div class="toolbar-group">
                <select id="slot-select">
                    <option value="1">Slot 1</option>
                    <option value="2">Slot 2</option>
                    <option value="3">Slot 3</option>
                    <option value="4">Slot 4</option>
                    <option value="5">Slot 5</option>
                </select>
                <button class="btn" onclick="saveSlot()">保存</button>
                <button class="btn" onclick="loadSlot()">読込</button>
            </div>
            <div class="toolbar-group">
                <button class="btn" onclick="copyCode()">コピー</button>
                <button class="btn" onclick="pasteCode()">ペースト</button>
                <button class="btn btn-danger" onclick="clearCode()">クリア</button>
            </div>
        </div>
        
        <textarea id="code-area" spellcheck="false" placeholder="ここにWebXR対応のHTMLコードを貼り付けてください..."></textarea>
        
        <button id="run-btn" onclick="runVR()">VRモード起動 (RUN)</button>
    </div>

    <div id="emulator-screen">
        <div id="exit-btn" onclick="exitVR()">×</div>
        <div id="gyro-status">Gyro: Ready</div>
        
        <iframe id="vr-frame"></iframe>

        <div id="controls-overlay">
            <div class="control-zone">
                <div id="joystick-area">
                    <div id="joystick-knob"></div>
                </div>
                <span style="color:#aaa; font-size:10px">MOVE</span>
            </div>
            
            <div class="control-zone">
                <div style="display:flex; gap:10px;">
                    <div class="v-btn" data-key="trigger">Trig</div>
                    <div class="v-btn" data-key="grip">Grip</div>
                </div>
                <div style="display:flex; gap:10px;">
                    <div class="v-btn" data-key="A">A</div>
                    <div class="v-btn" data-key="B">B</div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // === 1. WebXR Mock Library (Iframe内に注入されるコード) ===
        // 文字列として定義し、実行時にiframeのheadに書き込みます
        const MOCK_LIB_CODE = `
        <script>
        (function() {
            console.log("WebXR Emulator Mock Initialized inside Iframe");
            
            // 内部状態
            const state = {
                position: [0, 1.6, 0],
                quaternion: [0, 0, 0, 1],
                inputs: {
                    left: { axes: [0,0], buttons: {} },
                    right: { axes: [0,0], buttons: {} }
                }
            };

            // 親ウィンドウからのメッセージ受信
            window.addEventListener('message', (e) => {
                const msg = e.data;
                if (!msg || !msg.type) return;

                if (msg.type === 'updateInput') {
                    // コントローラー入力の更新
                    if(msg.hand === 'left') {
                        if(msg.axes) state.inputs.left.axes = msg.axes;
                    }
                    if(msg.hand === 'right') {
                        Object.assign(state.inputs.right.buttons, msg.buttons);
                    }
                }
                else if (msg.type === 'updatePose') {
                    // ジャイロ/移動による姿勢更新
                    if(msg.position) state.position = msg.position;
                    if(msg.quaternion) state.quaternion = msg.quaternion;
                }
            });

            // --- WebXR API Mock Class Definitions ---
            
            class MockXRSession {
                constructor() {
                    this.ended = false;
                    this.inputSources = [
                        this._createInputSource('left'),
                        this._createInputSource('right')
                    ];
                    this.renderState = { baseLayer: null };
                    this.viewerSpace = { name: 'viewer' };
                }

                _createInputSource(hand) {
                    return {
                        handedness: hand,
                        targetRayMode: 'tracked-pointer',
                        profiles: ['oculus-touch'],
                        gamepad: {
                            buttons: [
                                { pressed: false, value: 0 }, // Trigger
                                { pressed: false, value: 0 }, // Grip
                                { pressed: false, value: 0 }, // Pad
                                { pressed: false, value: 0 }, // Thumbstick
                                { pressed: false, value: 0 }, // A/X
                                { pressed: false, value: 0 }, // B/Y
                            ],
                            axes: [0, 0]
                        }
                    };
                }

                _updateInputSources() {
                    // 内部stateをgamepadオブジェクトに反映
                    const mapBtn = (btnState) => ({ pressed: !!btnState, value: btnState ? 1 : 0 });
                    
                    // Left (Joystick)
                    this.inputSources[0].gamepad.axes = state.inputs.left.axes;
                    
                    // Right (Buttons)
                    // Index: 0:Trig, 1:Grip, 4:A, 5:B (Standard Mapping概略)
                    const rBtns = state.inputs.right.buttons;
                    const gp = this.inputSources[1].gamepad.buttons;
                    gp[0] = mapBtn(rBtns.trigger);
                    gp[1] = mapBtn(rBtns.grip);
                    gp[4] = mapBtn(rBtns.A);
                    gp[5] = mapBtn(rBtns.B);
                }

                requestReferenceSpace(type) {
                    return Promise.resolve({
                        getViewerPose: (refSpace) => {
                            this._updateInputSources();
                            return {
                                transform: {
                                    position: { x: state.position[0], y: state.position[1], z: state.position[2], w: 1 },
                                    orientation: { x: state.quaternion[0], y: state.quaternion[1], z: state.quaternion[2], w: state.quaternion[3] },
                                    matrix: new Float32Array(16) // Matrix計算は省略（多くのエンジンはtransformを使う）
                                },
                                views: [{
                                    eye: 'left', // Monoscopic for mobile
                                    projectionMatrix: [1.2, 0, 0, 0, 0, 2.4, 0, 0, 0, 0, -1, -1, 0, 0, -0.2, 0], // Dummy Projection
                                    transform: { position: {x:0,y:0,z:0}, orientation: {x:0,y:0,z:0,w:1} },
                                    viewport: { x: 0, y: 0, width: window.innerWidth, height: window.innerHeight }
                                }]
                            };
                        }
                    });
                }
                
                updateRenderState(params) { 
                    if(params.baseLayer) this.renderState.baseLayer = params.baseLayer;
                }

                requestAnimationFrame(callback) {
                    if (this.ended) return 0;
                    return window.requestAnimationFrame((t) => {
                        callback(t, this);
                    });
                }
                
                end() { this.ended = true; return Promise.resolve(); }
                addEventListener() {}
                removeEventListener() {}
            }

            // Navigator Override
            const mockXR = {
                isSessionSupported: (mode) => Promise.resolve(mode === 'immersive-vr'),
                requestSession: (mode) => {
                    console.log("Session Requested: " + mode);
                    return Promise.resolve(new MockXRSession());
                }
            };

            // navigator.xr を上書き (configurableがtrueの場合のみ)
            try {
                Object.defineProperty(navigator, 'xr', { value: mockXR, configurable: true });
            } catch(e) {
                console.warn("Could not override navigator.xr directly, injecting to window.");
                window.navigator.xr = mockXR;
            }
            
        })();
        <\/script>
        `;

        // === 2. Editor & System Logic ===

        const codeArea = document.getElementById('code-area');
        const slotSelect = document.getElementById('slot-select');
        const editorScreen = document.getElementById('editor-screen');
        const emulatorScreen = document.getElementById('emulator-screen');
        const vrFrame = document.getElementById('vr-frame');
        
        // デフォルトのサンプルコード（Three.js）
        const DEFAULT_CODE = `<!DOCTYPE html>
<html>
<head>
  <style>body { margin: 0; background: #000; }</style>
  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.150.0/build/three.module.js';

    // シーン設定
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x202020);
    const camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 0.1, 100);
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true; // WebXR有効化
    document.body.appendChild(renderer.domElement);

    // オブジェクト作成
    const geometry = new THREE.BoxGeometry(0.2, 0.2, 0.2);
    const material = new THREE.MeshBasicMaterial({ color: 0x00ff00, wireframe: true });
    const cube = new THREE.Mesh(geometry, material);
    cube.position.set(0, 1.6, -1);
    scene.add(cube);
    
    // ライト
    const light = new THREE.HemisphereLight( 0xffffff, 0xbbbbff, 1 );
    scene.add( light );

    // アニメーションループ
    renderer.setAnimationLoop(() => {
        cube.rotation.x += 0.01;
        cube.rotation.y += 0.01;
        renderer.render(scene, camera);
    });

    // VRセッション自動開始 (エミュレーター用)
    // 通常はボタンクリックが必要だが、この環境では自動でリクエストする
    const startVR = async () => {
      if (navigator.xr) {
        try {
          const session = await navigator.xr.requestSession('immersive-vr');
          renderer.xr.setSession(session);
        } catch (e) { console.error("XR Start failed", e); }
      }
    };
    setTimeout(startVR, 1000);

  <\/script>
</head>
<body></body>
</html>`;

        // 初期化
        window.onload = () => {
            loadSlot(); // スロット1をロード、なければデフォルト
            if(!codeArea.value) codeArea.value = DEFAULT_CODE;
        };

        function saveSlot() {
            const slot = slotSelect.value;
            localStorage.setItem(`vr_emu_slot_${slot}`, codeArea.value);
            alert(`Slot ${slot} に保存しました`);
        }

        function loadSlot() {
            const slot = slotSelect.value;
            const data = localStorage.getItem(`vr_emu_slot_${slot}`);
            if (data) {
                codeArea.value = data;
            } else {
                // alert(`Slot ${slot} は空です`);
            }
        }

        function clearCode() {
            if(confirm('エディタをクリアしますか？')) codeArea.value = '';
        }

        async function copyCode() {
            try {
                await navigator.clipboard.writeText(codeArea.value);
                alert('コピーしました');
            } catch (err) { alert('コピー失敗: ' + err); }
        }

        async function pasteCode() {
            try {
                const text = await navigator.clipboard.readText();
                codeArea.value = text;
            } catch (err) { alert('ペースト失敗: ' + err); }
        }

        // === 3. Run & Emulator Logic ===
        
        // 姿勢管理変数
        let pose = { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 };
        let isGyroActive = false;
        let initialGyroAlpha = null;

        function runVR() {
            // ジャイロセンサーの許可リクエスト (iOS)
            if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                DeviceOrientationEvent.requestPermission()
                    .then(state => {
                        if (state === 'granted') startEmulator();
                        else alert('ジャイロ許可が必要です');
                    })
                    .catch(e => {
                        alert('ジャイロエラー: ' + e);
                        startEmulator(); // 失敗してもとりあえず起動
                    });
            } else {
                startEmulator();
            }
        }

        function startEmulator() {
            // UI切り替え
            editorScreen.style.display = 'none';
            emulatorScreen.style.display = 'block';
            
            // Iframe生成（モック注入 + ユーザーコード）
            const userCode = codeArea.value;
            const finalHtml = userCode.replace('<head>', '<head>' + MOCK_LIB_CODE);
            
            vrFrame.srcdoc = finalHtml;

            // センサー開始
            window.addEventListener('deviceorientation', handleOrientation);
            startLoop();
        }

        function exitVR() {
            emulatorScreen.style.display = 'none';
            editorScreen.style.display = 'flex';
            vrFrame.srcdoc = ''; // Reset
            window.removeEventListener('deviceorientation', handleOrientation);
            cancelAnimationFrame(animationFrameId);
            pose = { x: 0, y: 1.6, z: 0, yaw: 0, pitch: 0 }; // Reset pose
        }

        // --- Input Handling (Joystick & Buttons) ---
        
        const joyZone = document.getElementById('joystick-area');
        const joyKnob = document.getElementById('joystick-knob');
        let joyDrag = false;
        let joyCenter = {x:0, y:0};
        
        // Joystick
        joyZone.addEventListener('touchstart', e => {
            joyDrag = true;
            const rect = joyZone.getBoundingClientRect();
            joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
        }, {passive: false});

        joyZone.addEventListener('touchmove', e => {
            if(!joyDrag) return;
            e.preventDefault();
            const t = e.touches[0];
            const maxR = 35;
            let dx = t.clientX - joyCenter.x;
            let dy = t.clientY - joyCenter.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            
            if(dist > maxR) {
                dx = dx * (maxR/dist);
                dy = dy * (maxR/dist);
            }
            
            joyKnob.style.transform = `translate(calc(-50% + ${dx}px), calc(-50% + ${dy}px))`;
            
            // Send Axes to Iframe
            // WebXR axes: x(-1 left, 1 right), y(-1 up, 1 down)
            const ax = dx / maxR;
            const ay = dy / maxR;
            
            // Move Player (Simple implementation)
            const speed = 0.05;
            pose.x += (Math.cos(pose.yaw) * ax - Math.sin(pose.yaw) * ay) * speed;
            pose.z += (Math.sin(pose.yaw) * ax + Math.cos(pose.yaw) * ay) * speed;

            vrFrame.contentWindow.postMessage({
                type: 'updateInput', hand: 'left', axes: [ax, ay]
            }, '*');
            
        }, {passive: false});

        const resetJoy = () => {
            joyDrag = false;
            joyKnob.style.transform = `translate(-50%, -50%)`;
            vrFrame.contentWindow.postMessage({ type: 'updateInput', hand: 'left', axes: [0, 0] }, '*');
        };
        joyZone.addEventListener('touchend', resetJoy);
        joyZone.addEventListener('touchcancel', resetJoy);

        // Buttons
        document.querySelectorAll('.v-btn').forEach(btn => {
            const key = btn.dataset.key;
            const send = (pressed) => {
                const msg = { type: 'updateInput', hand: 'right', buttons: {} };
                msg.buttons[key] = pressed;
                vrFrame.contentWindow.postMessage(msg, '*');
            };
            btn.addEventListener('touchstart', (e) => { e.preventDefault(); send(true); });
            btn.addEventListener('touchend', (e) => { e.preventDefault(); send(false); });
        });

        // --- Orientation & Main Loop ---

        function handleOrientation(e) {
            if(!initialGyroAlpha && e.alpha) initialGyroAlpha = e.alpha;
            
            // 簡易的な計算 (Y軸回転=Alpha, X軸回転=Beta)
            // 実際はQuaternion変換が必要だが、簡易エミュレーションのためEulerを使用
            if(e.alpha !== null) {
                const radA = (e.alpha - initialGyroAlpha) * (Math.PI / 180);
                const radB = (e.beta - 90) * (Math.PI / 180); // スマホを縦に持った状態を基準にする補正
                
                // 実際はScreenOrientation APIなども考慮が必要だがここではシンプルに
                pose.yaw = -radA; // Alphaは反時計回り
                pose.pitch = radB;
                
                document.getElementById('gyro-status').textContent = `Gyro: ${Math.round(e.alpha)}, ${Math.round(e.beta)}`;
            }
        }

        let animationFrameId;
        function startLoop() {
            // Iframeに現在のPoseを送り続けるループ
            function loop() {
                if(emulatorScreen.style.display === 'none') return;

                // Euler to Quaternion (簡易)
                const c1 = Math.cos(pose.yaw / 2);
                const s1 = Math.sin(pose.yaw / 2);
                const c2 = Math.cos(pose.pitch / 2);
                const s2 = Math.sin(pose.pitch / 2);
                const c3 = Math.cos(0);
                const s3 = Math.sin(0);

                const qx = s1 * s2 * c3 + c1 * c2 * s3;
                const qy = s1 * c2 * c3 + c1 * s2 * s3;
                const qz = c1 * s2 * c3 - s1 * c2 * s3;
                const qw = c1 * c2 * c3 - s1 * s2 * s3;

                vrFrame.contentWindow.postMessage({
                    type: 'updatePose',
                    position: [pose.x, pose.y, pose.z],
                    quaternion: [qx, qy, qz, qw]
                }, '*');

                animationFrameId = requestAnimationFrame(loop);
            }
            loop();
        }

    </script>
</body>
</html>
